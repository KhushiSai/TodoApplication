{"ast":null,"code":"const API_BASE_URL = 'http://jsonplaceholder.typicode.com/todos';\n\n// Fallback data for when API is not available\nconst FALLBACK_TODOS = [{\n  userId: 1,\n  id: 1,\n  title: \"Learn React\",\n  completed: false\n}, {\n  userId: 1,\n  id: 2,\n  title: \"Build Todo App\",\n  completed: true\n}, {\n  userId: 1,\n  id: 3,\n  title: \"Master TypeScript\",\n  completed: false\n}, {\n  userId: 1,\n  id: 4,\n  title: \"Style with Tailwind\",\n  completed: true\n}, {\n  userId: 1,\n  id: 5,\n  title: \"Deploy to production\",\n  completed: false\n}];\nexport class TodoApiService {\n  // GET - Fetch all todos\n  static async getAllTodos() {\n    try {\n      const response = await fetch(API_BASE_URL, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        // Add timeout to prevent hanging\n        signal: AbortSignal.timeout(10000) // 10 second timeout\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const todos = await response.json();\n      return todos;\n    } catch (error) {\n      console.warn('API not available, using fallback data:', error);\n      // Return fallback data if API fails\n      return FALLBACK_TODOS;\n    }\n  }\n\n  // GET - Fetch a single todo by ID\n  static async getTodoById(id) {\n    try {\n      const response = await fetch(`${API_BASE_URL}/${id}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: AbortSignal.timeout(5000)\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const todo = await response.json();\n      return todo;\n    } catch (error) {\n      console.error(`Error fetching todo ${id}:`, error);\n      // Return a fallback todo\n      return {\n        userId: 1,\n        id,\n        title: `Todo ${id} (offline)`,\n        completed: false\n      };\n    }\n  }\n\n  // POST - Create a new todo\n  static async createTodo(todoData) {\n    try {\n      const response = await fetch(API_BASE_URL, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          ...todoData,\n          userId: 1 // Default user ID\n        }),\n        signal: AbortSignal.timeout(5000)\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const newTodo = await response.json();\n      return newTodo;\n    } catch (error) {\n      console.warn('API not available, creating local todo:', error);\n      // Create a local todo with a temporary ID\n      const tempId = Date.now();\n      return {\n        userId: 1,\n        id: tempId,\n        title: todoData.title,\n        completed: todoData.completed\n      };\n    }\n  }\n\n  // PUT - Update an existing todo\n  static async updateTodo(id, todoData) {\n    try {\n      const response = await fetch(`${API_BASE_URL}/${id}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(todoData),\n        signal: AbortSignal.timeout(5000)\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const updatedTodo = await response.json();\n      return updatedTodo;\n    } catch (error) {\n      console.warn('API not available, updating local todo:', error);\n      // Return the updated todo locally\n      return {\n        userId: 1,\n        id,\n        title: todoData.title || 'Updated Todo',\n        completed: todoData.completed || false\n      };\n    }\n  }\n\n  // PATCH - Partially update a todo\n  static async patchTodo(id, todoData) {\n    try {\n      const response = await fetch(`${API_BASE_URL}/${id}`, {\n        method: 'PATCH',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(todoData),\n        signal: AbortSignal.timeout(5000)\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const updatedTodo = await response.json();\n      return updatedTodo;\n    } catch (error) {\n      console.warn('API not available, patching local todo:', error);\n      // Return the patched todo locally\n      return {\n        userId: 1,\n        id,\n        title: todoData.title || 'Patched Todo',\n        completed: todoData.completed || false\n      };\n    }\n  }\n\n  // DELETE - Delete a todo\n  static async deleteTodo(id) {\n    try {\n      const response = await fetch(`${API_BASE_URL}/${id}`, {\n        method: 'DELETE',\n        signal: AbortSignal.timeout(5000)\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n    } catch (error) {\n      console.warn('API not available, deleting local todo:', error);\n      // For local deletion, we just return successfully\n      // The actual deletion will be handled by the state management\n    }\n  }\n}","map":{"version":3,"names":["API_BASE_URL","FALLBACK_TODOS","userId","id","title","completed","TodoApiService","getAllTodos","response","fetch","method","headers","signal","AbortSignal","timeout","ok","Error","status","todos","json","error","console","warn","getTodoById","todo","createTodo","todoData","body","JSON","stringify","newTodo","tempId","Date","now","updateTodo","updatedTodo","patchTodo","deleteTodo"],"sources":["C:/Users/hp/Desktop/todo6/src/services/todoApi.ts"],"sourcesContent":["import { Todo, TodoFormData, ApiResponse } from '../types/Todo';\r\n\r\nconst API_BASE_URL = 'http://jsonplaceholder.typicode.com/todos';\r\n\r\n// Fallback data for when API is not available\r\nconst FALLBACK_TODOS: Todo[] = [\r\n  { userId: 1, id: 1, title: \"Learn React\", completed: false },\r\n  { userId: 1, id: 2, title: \"Build Todo App\", completed: true },\r\n  { userId: 1, id: 3, title: \"Master TypeScript\", completed: false },\r\n  { userId: 1, id: 4, title: \"Style with Tailwind\", completed: true },\r\n  { userId: 1, id: 5, title: \"Deploy to production\", completed: false },\r\n];\r\n\r\nexport class TodoApiService {\r\n  // GET - Fetch all todos\r\n  static async getAllTodos(): Promise<Todo[]> {\r\n    try {\r\n      const response = await fetch(API_BASE_URL, {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        // Add timeout to prevent hanging\r\n        signal: AbortSignal.timeout(10000), // 10 second timeout\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      \r\n      const todos: Todo[] = await response.json();\r\n      return todos;\r\n    } catch (error) {\r\n      console.warn('API not available, using fallback data:', error);\r\n      // Return fallback data if API fails\r\n      return FALLBACK_TODOS;\r\n    }\r\n  }\r\n\r\n  // GET - Fetch a single todo by ID\r\n  static async getTodoById(id: number): Promise<Todo> {\r\n    try {\r\n      const response = await fetch(`${API_BASE_URL}/${id}`, {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        signal: AbortSignal.timeout(5000),\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      \r\n      const todo: Todo = await response.json();\r\n      return todo;\r\n    } catch (error) {\r\n      console.error(`Error fetching todo ${id}:`, error);\r\n      // Return a fallback todo\r\n      return { userId: 1, id, title: `Todo ${id} (offline)`, completed: false };\r\n    }\r\n  }\r\n\r\n  // POST - Create a new todo\r\n  static async createTodo(todoData: TodoFormData): Promise<Todo> {\r\n    try {\r\n      const response = await fetch(API_BASE_URL, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          ...todoData,\r\n          userId: 1, // Default user ID\r\n        }),\r\n        signal: AbortSignal.timeout(5000),\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      \r\n      const newTodo: Todo = await response.json();\r\n      return newTodo;\r\n    } catch (error) {\r\n      console.warn('API not available, creating local todo:', error);\r\n      // Create a local todo with a temporary ID\r\n      const tempId = Date.now();\r\n      return {\r\n        userId: 1,\r\n        id: tempId,\r\n        title: todoData.title,\r\n        completed: todoData.completed,\r\n      };\r\n    }\r\n  }\r\n\r\n  // PUT - Update an existing todo\r\n  static async updateTodo(id: number, todoData: Partial<Todo>): Promise<Todo> {\r\n    try {\r\n      const response = await fetch(`${API_BASE_URL}/${id}`, {\r\n        method: 'PUT',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(todoData),\r\n        signal: AbortSignal.timeout(5000),\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      \r\n      const updatedTodo: Todo = await response.json();\r\n      return updatedTodo;\r\n    } catch (error) {\r\n      console.warn('API not available, updating local todo:', error);\r\n      // Return the updated todo locally\r\n      return {\r\n        userId: 1,\r\n        id,\r\n        title: todoData.title || 'Updated Todo',\r\n        completed: todoData.completed || false,\r\n      };\r\n    }\r\n  }\r\n\r\n  // PATCH - Partially update a todo\r\n  static async patchTodo(id: number, todoData: Partial<Todo>): Promise<Todo> {\r\n    try {\r\n      const response = await fetch(`${API_BASE_URL}/${id}`, {\r\n        method: 'PATCH',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(todoData),\r\n        signal: AbortSignal.timeout(5000),\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      \r\n      const updatedTodo: Todo = await response.json();\r\n      return updatedTodo;\r\n    } catch (error) {\r\n      console.warn('API not available, patching local todo:', error);\r\n      // Return the patched todo locally\r\n      return {\r\n        userId: 1,\r\n        id,\r\n        title: todoData.title || 'Patched Todo',\r\n        completed: todoData.completed || false,\r\n      };\r\n    }\r\n  }\r\n\r\n  // DELETE - Delete a todo\r\n  static async deleteTodo(id: number): Promise<void> {\r\n    try {\r\n      const response = await fetch(`${API_BASE_URL}/${id}`, {\r\n        method: 'DELETE',\r\n        signal: AbortSignal.timeout(5000),\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n    } catch (error) {\r\n      console.warn('API not available, deleting local todo:', error);\r\n      // For local deletion, we just return successfully\r\n      // The actual deletion will be handled by the state management\r\n    }\r\n  }\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}